// Generated by CoffeeScript 1.6.3
var CameraFollowingSystem, CanvasRenderSystem, InputSystem, MovementSystem, PokemonMovementSystem, RandomInputSystem, TilemapRenderingSystem, TweenSystem;

PokemonMovementSystem = (function() {
  function PokemonMovementSystem() {}

  PokemonMovementSystem.prototype.update = function(delta, entityManager, assetManager) {
    var arrows, canMove, collisionLayer, direction, dx, dy, entity, gridPosition, movement, moving, nextTile, otherGridPosition, pixelPosition, tileIdx, tween, tweens, _, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = entityManager.iterateEntitiesWithComponents(['PokemonMovementComponent', 'DirectionComponent', 'ActionInputComponent', 'GridPositionComponent', 'PixelPositionComponent']);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], entity = _ref1[0], movement = _ref1[1], direction = _ref1[2], arrows = _ref1[3], gridPosition = _ref1[4], pixelPosition = _ref1[5];
      tweens = entityManager.getComponents(entity, 'TweenComponent');
      moving = false;
      for (_j = 0, _len1 = tweens.length; _j < _len1; _j++) {
        tween = tweens[_j];
        if (tween.component === pixelPosition) {
          moving = true;
          break;
        }
      }
      if (!moving) {
        gridPosition.col = Math.round(pixelPosition.x / gridPosition.gridSize);
        gridPosition.row = Math.round(pixelPosition.y / gridPosition.gridSize);
        dx = dy = 0;
        if (arrows.left) {
          dx -= 1;
        }
        if (arrows.right) {
          dx += 1;
        }
        if (dx === 0) {
          if (arrows.up) {
            dy -= 1;
          }
          if (arrows.down) {
            dy += 1;
          }
        }
        if (dx > 0 || dx < 0 || dy > 0 || dy < 0) {
          if (dx < 0) {
            direction.direction = 'left';
          }
          if (dx > 0) {
            direction.direction = 'right';
          }
          if (dy < 0) {
            direction.direction = 'up';
          }
          if (dy > 0) {
            direction.direction = 'down';
          }
          _results.push((function() {
            var _k, _l, _len2, _len3, _ref2, _ref3, _ref4, _ref5, _results1;
            _ref2 = entityManager.iterateEntitiesWithComponents(['TilemapCollisionLayerComponent']);
            _results1 = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              _ref3 = _ref2[_k], _ = _ref3[0], collisionLayer = _ref3[1];
              tileIdx = (gridPosition.row + dy) * collisionLayer.tileData.width + (gridPosition.col + dx);
              nextTile = collisionLayer.tileData.data[tileIdx];
              if (nextTile === 0) {
                canMove = true;
                _ref4 = entityManager.iterateEntitiesWithComponents(['GridPositionComponent', 'CollidableComponent']);
                for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
                  _ref5 = _ref4[_l], _ = _ref5[0], otherGridPosition = _ref5[1], _ = _ref5[2];
                  if ((gridPosition.col + dx) === otherGridPosition.col && (gridPosition.row + dy) === otherGridPosition.row) {
                    canMove = false;
                  }
                }
                if (canMove) {
                  if (dx > 0 || dx < 0) {
                    entityManager.addComponent(entity, 'TweenComponent', {
                      speed: movement.speed,
                      start: pixelPosition.x,
                      dest: pixelPosition.x + gridPosition.gridSize * dx,
                      component: pixelPosition,
                      attr: 'x',
                      easingFn: 'linear'
                    });
                  }
                  if (dy > 0 || dy < 0) {
                    entityManager.addComponent(entity, 'TweenComponent', {
                      speed: movement.speed,
                      start: pixelPosition.y,
                      dest: pixelPosition.y + gridPosition.gridSize * dy,
                      component: pixelPosition,
                      attr: 'y',
                      easingFn: 'linear'
                    });
                  }
                  _results1.push(gridPosition.doSync = false);
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return PokemonMovementSystem;

})();

TweenSystem = (function() {
  function TweenSystem() {}

  TweenSystem.prototype.update = function(delta, entityManager, assetManager) {
    var b, c, dir, entity, t, tween, _i, _len, _ref, _ref1, _results;
    _ref = entityManager.iterateEntitiesWithComponents(['TweenComponent']);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], entity = _ref1[0], tween = _ref1[1];
      if (tween.start === tween.dest) {
        entityManager.removeComponent(entity, tween);
      }
      if (tween.current === null) {
        tween.current = tween.start;
      }
      dir = tween.start < tween.dest ? 1 : -1;
      if (tween.easingFn === 'linear') {
        tween.current += delta * tween.speed * dir;
      } else if (tween.easingFn === 'ease-out-bounce') {
        t = Math.abs(tween.current / tween.dest);
        c = delta * tween.speed * dir;
        b = tween.start;
        if (t < (1 / 2.75)) {
          tween.current = c * (7.5625 * t * t) + b;
        } else if (t < (2 / 2.75)) {
          tween.current = c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b;
        } else if (t < (2.5 / 2.75)) {
          tween.current = c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b;
        } else {
          tween.current = c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b;
        }
      }
      tween.component[tween.attr] = tween.current;
      if ((tween.start < tween.dest && tween.current > tween.dest) || (tween.start >= tween.dest && tween.current < tween.dest)) {
        tween.component[tween.attr] = tween.dest;
        _results.push(entityManager.removeComponent(entity, tween));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return TweenSystem;

})();

CanvasRenderSystem = (function() {
  function CanvasRenderSystem(cq) {
    this.cq = cq;
  }

  CanvasRenderSystem.prototype.update = function(delta, entityManager, assetManager) {
    var camera, cameraPosition, color, direction, entity, fromX, fromY, position, shape, toX, toY, _i, _len, _ref, _ref1, _results;
    camera = entityManager.getEntitiesWithComponents(['CameraComponent', 'PixelPositionComponent']);
    cameraPosition = entityManager.getComponent(camera, 'PixelPositionComponent');
    _ref = entityManager.iterateEntitiesWithComponents(['PixelPositionComponent', 'ColorComponent', 'ShapeRendererComponent', 'DirectionComponent']);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], entity = _ref1[0], position = _ref1[1], color = _ref1[2], shape = _ref1[3], direction = _ref1[4];
      this.cq.fillStyle(color.color);
      if (shape.type === 'rectangle') {
        this.cq.fillRect(position.x - cameraPosition.x, position.y - cameraPosition.y, shape.width, shape.height);
        this.cq.beginPath();
        fromX = position.x + shape.width / 2;
        fromY = position.y + shape.height / 2;
        fromX -= cameraPosition.x;
        fromY -= cameraPosition.y;
        this.cq.moveTo(fromX, fromY);
        toX = fromX;
        toY = fromY;
        switch (direction.direction) {
          case 'left':
            toX -= shape.width / 2;
            break;
          case 'right':
            toX += shape.width / 2;
            break;
          case 'up':
            toY -= shape.width / 2;
            break;
          case 'down':
            toY += shape.width / 2;
        }
        this.cq.lineTo(toX, toY);
        this.cq.lineWidth = 4;
        this.cq.strokeStyle = 'black';
        this.cq.lineCap = 'round';
        _results.push(this.cq.stroke());
      } else {
        throw 'NotImplementedException';
      }
    }
    return _results;
  };

  return CanvasRenderSystem;

})();

InputSystem = (function() {
  function InputSystem() {}

  InputSystem.prototype.updateKey = function(key, value, entityManager, assetManager) {
    var arrows, entity, _, _i, _len, _ref, _ref1, _results;
    _ref = entityManager.iterateEntitiesWithComponents(['KeyboardArrowsInputComponent', 'ActionInputComponent']);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], entity = _ref1[0], _ = _ref1[1], arrows = _ref1[2];
      switch (key) {
        case 'left':
          _results.push(arrows.left = value);
          break;
        case 'right':
          _results.push(arrows.right = value);
          break;
        case 'up':
          _results.push(arrows.up = value);
          break;
        case 'down':
          _results.push(arrows.down = value);
          break;
        default:
          _results.push(void 0);
      }
    }
    return _results;
  };

  return InputSystem;

})();

RandomInputSystem = (function() {
  function RandomInputSystem() {}

  RandomInputSystem.prototype.update = function(delta, entityManager, assetManager) {
    var arrows, chance, entity, _, _i, _len, _ref, _ref1, _results;
    _ref = entityManager.iterateEntitiesWithComponents(['RandomArrowsInputComponent', 'ActionInputComponent']);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], entity = _ref1[0], _ = _ref1[1], arrows = _ref1[2];
      arrows.left = arrows.right = arrows.up = arrows.down = false;
      chance = 0.002;
      if (Math.random() < chance) {
        arrows.left = true;
      }
      if (Math.random() < chance) {
        arrows.right = true;
      }
      if (Math.random() < chance) {
        arrows.up = true;
      }
      if (Math.random() < chance) {
        _results.push(arrows.down = true);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return RandomInputSystem;

})();

MovementSystem = (function() {
  function MovementSystem() {}

  MovementSystem.prototype.update = function(delta, entityManager, assetManager) {
    var arrows, entity, position, velocity, _i, _len, _ref, _ref1, _results;
    _ref = entityManager.iterateEntitiesWithComponents(['PixelPositionComponent', 'VelocityComponent', 'ArrowKeyInputComponent']);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], entity = _ref1[0], position = _ref1[1], velocity = _ref1[2], arrows = _ref1[3];
      velocity.dx = velocity.dy = 0;
      if (arrows.left) {
        velocity.dx -= velocity.maxSpeed * delta;
      }
      if (arrows.right) {
        velocity.dx += velocity.maxSpeed * delta;
      }
      if (arrows.up) {
        velocity.dy -= velocity.maxSpeed * delta;
      }
      if (arrows.down) {
        velocity.dy += velocity.maxSpeed * delta;
      }
      position.x += velocity.dx;
      _results.push(position.y += velocity.dy);
    }
    return _results;
  };

  return MovementSystem;

})();

CameraFollowingSystem = (function() {
  function CameraFollowingSystem() {}

  CameraFollowingSystem.prototype.update = function(delta, entityManager, assetManager) {
    var camera, cameraPosition, followee, followeePosition, mapLayer, mapLayerComponent;
    camera = entityManager.getSingletonEntityWithComponent('CameraComponent');
    cameraPosition = entityManager.getComponent(camera, 'PixelPositionComponent');
    followee = entityManager.getSingletonEntityWithComponent('CameraFollowsComponent');
    followeePosition = entityManager.getComponent(followee, 'PixelPositionComponent');
    mapLayer = entityManager.getEntitiesWithComponent('TilemapVisibleLayerComponent')[0];
    mapLayerComponent = entityManager.getComponent(mapLayer, 'TilemapVisibleLayerComponent');
    cameraPosition.x = followeePosition.x - (Game.SCREEN_WIDTH / 2 - 32);
    cameraPosition.y = followeePosition.y - (Game.SCREEN_HEIGHT / 2 - 16);
    if (cameraPosition.x < 0) {
      cameraPosition.x = 0;
    }
    if (cameraPosition.y < 0) {
      return cameraPosition.y = 0;
    }
  };

  return CameraFollowingSystem;

})();

TilemapRenderingSystem = (function() {
  function TilemapRenderingSystem(cq) {
    this.cq = cq;
  }

  TilemapRenderingSystem.prototype.update = function(delta, entityManager, assetManager) {
    var camera, cameraPosition, col, endCol, endRow, entities, entity, layer, layers, row, screenX, screenY, startCol, startRow, thisTile, thisTileImageX, thisTileImageY, tileIdx, tileImage, tileImageTilesHigh, tileImageTilesWide, _i, _j, _len, _len1, _results;
    camera = entityManager.getSingletonEntityWithComponent('CameraComponent');
    cameraPosition = entityManager.getComponent(camera, 'PixelPositionComponent');
    entities = entityManager.getEntitiesWithComponent('TilemapVisibleLayerComponent');
    layers = [];
    for (_i = 0, _len = entities.length; _i < _len; _i++) {
      entity = entities[_i];
      layers.push(entityManager.getComponent(entity, 'TilemapVisibleLayerComponent'));
    }
    layers.sort(function(a, b) {
      return a.zIndex - b.zIndex;
    });
    _results = [];
    for (_j = 0, _len1 = layers.length; _j < _len1; _j++) {
      layer = layers[_j];
      tileImage = assetManager.assets[layer.tileImageUrl];
      tileImageTilesWide = tileImage.width / layer.tileWidth;
      tileImageTilesHigh = tileImage.height / layer.tileHeight;
      startCol = Math.floor(cameraPosition.x / layer.tileWidth);
      startRow = Math.floor(cameraPosition.y / layer.tileHeight);
      endCol = startCol + Math.ceil(Game.SCREEN_WIDTH / layer.tileWidth);
      endRow = startRow + Math.ceil(Game.SCREEN_HEIGHT / layer.tileWidth);
      _results.push((function() {
        var _k, _results1;
        _results1 = [];
        for (row = _k = startRow; startRow <= endRow ? _k <= endRow : _k >= endRow; row = startRow <= endRow ? ++_k : --_k) {
          _results1.push((function() {
            var _l, _results2;
            _results2 = [];
            for (col = _l = startCol; startCol <= endCol ? _l <= endCol : _l >= endCol; col = startCol <= endCol ? ++_l : --_l) {
              tileIdx = row * layer.tileData.width + col;
              if (col < layer.tileData.width && col >= 0 && row < layer.tileData.height && row >= 0) {
                thisTile = layer.tileData.data[tileIdx] - 1;
                thisTileImageX = (thisTile % tileImageTilesWide) * layer.tileWidth;
                thisTileImageY = Math.floor(thisTile / tileImageTilesWide) * layer.tileHeight;
                screenX = Math.floor(col * layer.tileWidth - cameraPosition.x);
                screenY = Math.floor(row * layer.tileHeight - cameraPosition.y);
                _results2.push(this.cq.drawImage(tileImage, thisTileImageX, thisTileImageY, layer.tileWidth, layer.tileHeight, screenX, screenY, layer.tileWidth, layer.tileHeight));
              } else {
                _results2.push(void 0);
              }
            }
            return _results2;
          }).call(this));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  return TilemapRenderingSystem;

})();
